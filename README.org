* Introduction
This is a simple string library that is more a proof of concept more than
anything else. It includes the in place small string optimization and you shoud
be able to return those stack objects fine by copy. the large string heap
version should also be fine by copy. I'm not happy with the api and keep trying
to simplify it.

Alot of basic functionality, such as looping over the contents of the string, it
is easier to just get a slice from the string and use that so things like basic
iterators are not implemented, and I feel would just clutter the API, be
slower, and be more places for bugs.

I tried to use the std.mem functions where possible but sometimes they were just
too slow or didn't fit the API well. In some cases I probably don't know they
even exist. Std is just a mess -- I hope there are plans to clean it up.

* Allocations
Some of allocator arguments are optional for cases where you
know you wont need it, but for functions like reserve where it is always needed
(unless you are making unnecessary reserve calls) it is still required. I was
thinking of just making all allocator arguments optional but it doesn't make
sense in some cases but might make the api simplier.

* Extend to small vec
It should be possible to use this for u8 numbers already if you just ignore the
word string all over the place. It should also be possible to wrap this in a
type function and have it use u16 or other, but it becomes much more limited and
I think there are better ways to do small vecs. Usually you don't need to spill
characteristics and you know if you will have large or small vectors at compile
time, and if you don't it is usually easier to manage than strings. I'd be more
include to just write a small vec implementation with no spillage.

* Usage without the union String indirection
Often you will now if you have a small or large string. for example, if you use
this as a hash key and know your key length. you can use SmallString and
LargeString directly if you want or you can still use String and call into
String.small or String.large if you already know. There is also some isSmall and
isLargeStr predicates to help with that. String.lowbyte is also there to help
determine the union type.

* Stuff already in std.mem?
I'm tempted to reimplement some of stuff in std.mem or at least
specialize it a little better. Some of the code is okay an some of it kind of
sucks, but it can easily be used by grabbing the slice and calling it on that
most of the time. There are some instances ike where you want to split the
string on multiple indexes where that doesn't work as well anymore though. I'll
add them to here as needed and I think leave the called to call the std.mem
functions, i think -- still not sure on it.

* Everything is a slice?
The API might change somewhat substantially by making any function that takes in
a string or null terminated string just take a slice instead. This should
simplify the API a little.

* Get rid of the allocator indirection?
Would making alloc arguments be anytype help with performance? You just so
rarely see the allocator chosen dynamically that it seems unnecessary.

* TODO
- [ ] better documentation
- [ ] refine shift xor search, add to API
- [ ] BM and online KMP
